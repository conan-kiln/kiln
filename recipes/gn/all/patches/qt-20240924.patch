diff -ur --new-file a/base/numerics/safe_conversions_arm_impl.h b/base/numerics/safe_conversions_arm_impl.h
--- /dev/null
+++ b/base/numerics/safe_conversions_arm_impl.h
@@ -0,0 +1,51 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef BASE_NUMERICS_SAFE_CONVERSIONS_ARM_IMPL_H_
+#define BASE_NUMERICS_SAFE_CONVERSIONS_ARM_IMPL_H_
+
+#include <cassert>
+#include <limits>
+#include <type_traits>
+
+#include "base/numerics/safe_conversions_impl.h"
+
+namespace base {
+namespace internal {
+
+// Fast saturation to a destination type.
+template <typename Dst, typename Src>
+struct SaturateFastAsmOp {
+  static const bool is_supported =
+      std::is_signed<Src>::value && std::is_integral<Dst>::value &&
+      std::is_integral<Src>::value &&
+      IntegerBitsPlusSign<Src>::value <= IntegerBitsPlusSign<int32_t>::value &&
+      IntegerBitsPlusSign<Dst>::value <= IntegerBitsPlusSign<int32_t>::value &&
+      !IsTypeInRangeForNumericType<Dst, Src>::value;
+
+  __attribute__((always_inline)) static Dst Do(Src value) {
+    int32_t src = value;
+    typename std::conditional<std::is_signed<Dst>::value, int32_t,
+                              uint32_t>::type result;
+    if (std::is_signed<Dst>::value) {
+      asm("ssat %[dst], %[shift], %[src]"
+          : [dst] "=r"(result)
+          : [src] "r"(src), [shift] "n"(IntegerBitsPlusSign<Dst>::value <= 32
+                                            ? IntegerBitsPlusSign<Dst>::value
+                                            : 32));
+    } else {
+      asm("usat %[dst], %[shift], %[src]"
+          : [dst] "=r"(result)
+          : [src] "r"(src), [shift] "n"(IntegerBitsPlusSign<Dst>::value < 32
+                                            ? IntegerBitsPlusSign<Dst>::value
+                                            : 31));
+    }
+    return static_cast<Dst>(result);
+  }
+};
+
+}  // namespace internal
+}  // namespace base
+
+#endif  // BASE_NUMERICS_SAFE_CONVERSIONS_ARM_IMPL_H_
diff -ur --new-file a/base/numerics/safe_math_arm_impl.h b/base/numerics/safe_math_arm_impl.h
--- /dev/null
+++ b/base/numerics/safe_math_arm_impl.h
@@ -0,0 +1,122 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef BASE_NUMERICS_SAFE_MATH_ARM_IMPL_H_
+#define BASE_NUMERICS_SAFE_MATH_ARM_IMPL_H_
+
+#include <cassert>
+#include <limits>
+#include <type_traits>
+
+#include "base/numerics/safe_conversions.h"
+
+namespace base {
+namespace internal {
+
+template <typename T, typename U>
+struct CheckedMulFastAsmOp {
+  static const bool is_supported =
+      FastIntegerArithmeticPromotion<T, U>::is_contained;
+
+  // The following is much more efficient than the Clang and GCC builtins for
+  // performing overflow-checked multiplication when a twice wider type is
+  // available. The below compiles down to 2-3 instructions, depending on the
+  // width of the types in use.
+  // As an example, an int32_t multiply compiles to:
+  //    smull   r0, r1, r0, r1
+  //    cmp     r1, r1, asr #31
+  // And an int16_t multiply compiles to:
+  //    smulbb  r1, r1, r0
+  //    asr     r2, r1, #16
+  //    cmp     r2, r1, asr #15
+  template <typename V>
+  __attribute__((always_inline)) static bool Do(T x, U y, V* result) {
+    using Promotion = typename FastIntegerArithmeticPromotion<T, U>::type;
+    Promotion presult;
+
+    presult = static_cast<Promotion>(x) * static_cast<Promotion>(y);
+    *result = static_cast<V>(presult);
+    return IsValueInRangeForNumericType<V>(presult);
+  }
+};
+
+template <typename T, typename U>
+struct ClampedAddFastAsmOp {
+  static const bool is_supported =
+      BigEnoughPromotion<T, U>::is_contained &&
+      IsTypeInRangeForNumericType<
+          int32_t,
+          typename BigEnoughPromotion<T, U>::type>::value;
+
+  template <typename V>
+  __attribute__((always_inline)) static V Do(T x, U y) {
+    // This will get promoted to an int, so let the compiler do whatever is
+    // clever and rely on the saturated cast to bounds check.
+    if (IsIntegerArithmeticSafe<int, T, U>::value)
+      return saturated_cast<V>(x + y);
+
+    int32_t result;
+    int32_t x_i32 = x;
+    int32_t y_i32 = y;
+
+    asm("qadd %[result], %[first], %[second]"
+        : [result] "=r"(result)
+        : [first] "r"(x_i32), [second] "r"(y_i32));
+    return saturated_cast<V>(result);
+  }
+};
+
+template <typename T, typename U>
+struct ClampedSubFastAsmOp {
+  static const bool is_supported =
+      BigEnoughPromotion<T, U>::is_contained &&
+      IsTypeInRangeForNumericType<
+          int32_t,
+          typename BigEnoughPromotion<T, U>::type>::value;
+
+  template <typename V>
+  __attribute__((always_inline)) static V Do(T x, U y) {
+    // This will get promoted to an int, so let the compiler do whatever is
+    // clever and rely on the saturated cast to bounds check.
+    if (IsIntegerArithmeticSafe<int, T, U>::value)
+      return saturated_cast<V>(x - y);
+
+    int32_t result;
+    int32_t x_i32 = x;
+    int32_t y_i32 = y;
+
+    asm("qsub %[result], %[first], %[second]"
+        : [result] "=r"(result)
+        : [first] "r"(x_i32), [second] "r"(y_i32));
+    return saturated_cast<V>(result);
+  }
+};
+
+template <typename T, typename U>
+struct ClampedMulFastAsmOp {
+  static const bool is_supported = CheckedMulFastAsmOp<T, U>::is_supported;
+
+  template <typename V>
+  __attribute__((always_inline)) static V Do(T x, U y) {
+    // Use the CheckedMulFastAsmOp for full-width 32-bit values, because
+    // it's fewer instructions than promoting and then saturating.
+    if (!IsIntegerArithmeticSafe<int32_t, T, U>::value &&
+        !IsIntegerArithmeticSafe<uint32_t, T, U>::value) {
+      V result;
+      if (CheckedMulFastAsmOp<T, U>::Do(x, y, &result))
+        return result;
+      return CommonMaxOrMin<V>(IsValueNegative(x) ^ IsValueNegative(y));
+    }
+
+    assert((FastIntegerArithmeticPromotion<T, U>::is_contained));
+    using Promotion = typename FastIntegerArithmeticPromotion<T, U>::type;
+    return saturated_cast<V>(static_cast<Promotion>(x) *
+                             static_cast<Promotion>(y));
+  }
+};
+
+}  // namespace internal
+}  // namespace base
+
+#endif  // BASE_NUMERICS_SAFE_MATH_ARM_IMPL_H_
diff -ur --new-file a/build/build_clang_cl.ninja.template b/build/build_clang_cl.ninja.template
--- /dev/null
+++ b/build/build_clang_cl.ninja.template
@@ -0,0 +1,12 @@
+rule cxx
+  command = $cxx /nologo /showIncludes /FC $includes $cflags /c $in /Fo$out
+  description = CXX $out
+  deps = msvc
+
+rule alink_thin
+  command = $ar /nologo /ignore:4221 $libflags /OUT:$out $in
+  description = LIB $out
+
+rule link
+  command = $ld /nologo $ldflags /OUT:$out /PDB:$out.pdb $in $solibs $libs
+  description = LINK $out
diff -ur --new-file a/build/build_mingw.ninja.template b/build/build_mingw.ninja.template
--- /dev/null
+++ b/build/build_mingw.ninja.template
@@ -0,0 +1,13 @@
+rule cxx
+  command = $cxx -MMD -MF $out.d $includes $cflags -c $in -o $out
+  description = CXX $out
+  depfile = $out.d
+  deps = gcc
+
+rule alink_thin
+  command = cmd /c del $out && $ar rcsT $out $in
+  description = AR $out
+
+rule link
+  command = $ld $ldflags -o $out -Wl,--start-group $in $libs -Wl,--end-group $solibs
+  description = LINK $out
diff -ur --new-file a/build/build_win.ninja.template b/build/build_win.ninja.template
--- a/build/build_win.ninja.template
+++ b/build/build_win.ninja.template
@@ -8,5 +8,5 @@
   description = LIB $out
 
 rule link
-  command = $ld /nologo $ldflags /OUT:$out /PDB:$out.pdb $in $solibs $libs
+  command = $ld /nologo $in /link $ldflags /PDB:$out.pdb /OUT:$out $solibs $libs
   description = LINK $out
diff -ur --new-file a/build/gen.py b/build/gen.py
--- a/build/gen.py
+++ b/build/gen.py
@@ -200,6 +200,22 @@
   args_list.add('--allow-warnings', action='store_true', default=False,
                     help=('Allow compiler warnings, don\'t treat them as '
                           'errors.'))
+  args_list.add('--cc',
+                    help='The path to cc compiler.')
+  args_list.add('--cxx',
+                    help='The path to cxx compiler.')
+  args_list.add('--ld',
+                    help='The path to ld.')
+  args_list.add('--ar',
+                    help='The path to ar.')
+  args_list.add('--isysroot',
+                    help='The path to the macOS SDK sysroot to be used.')
+  args_list.add('--qt-version',
+                    help="The qt version gn is compiled for.")
+  args_list.add('--osx-architectures',
+                    help='delimited list of architectures for universal build',
+                    type=str)
+
   if sys.platform == 'zos':
     args_list.add('--zoslib-dir',
                       action='store',
@@ -209,7 +225,6 @@
                             'with <ZOSLIB_DIR>/install/lib/libzoslib.a, and ' +
                             'add -I<ZOSLIB_DIR>/install/include to the compile ' +
                             'commands. See README.md for details.'))
-
   args_list.add_to_parser(parser)
   options = parser.parse_args(argv)
 
@@ -225,6 +240,9 @@
   if not options.no_last_commit_position:
     GenerateLastCommitPosition(host,
                                os.path.join(out_dir, 'last_commit_position.h'))
+  if options.qt_version:
+      generate_qt_version_header(options.qt_version, os.path.join(out_dir, 'qt_version.h'))
+
   WriteGNNinja(os.path.join(out_dir, 'build.ninja'), platform, host, options, args_list)
   return 0
 
@@ -295,10 +313,15 @@
     '',
   ]
 
+  platform_template = platform.platform()
+
+  if "clang-cl" in cxx:
+     platform_template = "clang-cl"
 
   template_filename = os.path.join(SCRIPT_DIR, {
       'msvc': 'build_win.ninja.template',
-      'mingw': 'build_linux.ninja.template',
+      'mingw': 'build_mingw.ninja.template',
+      'clang-cl': 'build_clang_cl.ninja.template',
       'msys': 'build_linux.ninja.template',
       'darwin': 'build_mac.ninja.template',
       'linux': 'build_linux.ninja.template',
@@ -310,7 +333,7 @@
       'netbsd': 'build_linux.ninja.template',
       'zos': 'build_zos.ninja.template',
       'serenity': 'build_linux.ninja.template',
-  }[platform.platform()])
+  }[platform_template])
 
   with open(template_filename) as f:
     ninja_template = f.read()
@@ -412,6 +435,22 @@
   cflags += os.environ.get('CXXFLAGS', '').split()
   ldflags = os.environ.get('LDFLAGS', '').split()
   libflags = os.environ.get('LIBFLAGS', '').split()
+
+  if options.cc:
+    cc = options.cc
+  if options.cxx:
+    cxx = options.cxx
+  if options.ld:
+    ld = options.ld
+  if options.ar:
+    ar = options.ar
+
+  if not ar:
+     if platform.is_msvc():
+        ar = os.environ.get('AR', 'lib.exe')
+     else:
+        ar = os.environ.get('AR', 'ar')
+
   include_dirs = [
       os.path.relpath(os.path.join(REPO_ROOT, 'src'), os.path.dirname(path)),
       '.',
@@ -420,6 +459,9 @@
     include_dirs += [ options.zoslib_dir + '/install/include' ]
 
   libs = []
+
+  if options.no_last_commit_position:
+      cflags.append('-DNO_LAST_COMMIT_POSITION')
 
   if not platform.is_msvc():
     if options.debug:
@@ -436,6 +478,10 @@
       if options.no_strip:
         cflags.append('-g')
       ldflags.append('-O3')
+      if platform.is_darwin() and options.isysroot:
+        cflags.append('-isysroot ' +  options.isysroot)
+        ldflags.append('-isysroot ' +  options.isysroot)
+
       # Use -fdata-sections and -ffunction-sections to place each function
       # or data item into its own section so --gc-sections can eliminate any
       # unused functions and data items.
@@ -510,6 +556,7 @@
       if not options.no_static_libstdcpp:
         ldflags.append('-static-libstdc++')
 
+      cflags.remove('-std=c++20')
       cflags.extend([
         '-Wno-deprecated-copy',
         '-Wno-implicit-fallthrough',
@@ -518,12 +565,17 @@
         '-Wno-format',             # Use of %llx, which is supported by _UCRT, false positive
         '-Wno-strict-aliasing',    # Dereferencing punned pointer
         '-Wno-cast-function-type', # Casting FARPROC to RegDeleteKeyExPtr
+        '-std=gnu++20',
       ])
-
     elif platform.is_darwin():
       min_mac_version_flag = '-mmacosx-version-min=10.9'
       cflags.append(min_mac_version_flag)
       ldflags.append(min_mac_version_flag)
+      if options.osx_architectures:
+         arch_list = [str(arch) for arch in options.osx_architectures.split(',')]
+         for arch in arch_list:
+           cflags.extend(['-arch',arch])
+           ldflags.extend(['-arch',arch])
     elif platform.is_aix():
       cflags.append('-maix64')
       ldflags.append('-maix64')
@@ -584,6 +636,7 @@
         '/wd4244',
         '/wd4267',
         '/wd4505',
+        '/wd4577',
         '/wd4838',
         '/wd4996',
         '/std:c++20',
@@ -593,8 +646,15 @@
 
     win_manifest = os.path.relpath(
       os.path.join(REPO_ROOT, "build/windows.manifest.xml"), options.out_path)
-    ldflags.extend(['/DEBUG', '/MACHINE:x64', '/MANIFEST:EMBED',
+    ldflags.extend(['/DEBUG', '/MANIFEST:EMBED',
                     f'/MANIFESTINPUT:{win_manifest}'])
+    target_arch = windows_target_build_arch()
+    if target_arch == 'x64':
+        ldflags.extend(['/MACHINE:x64'])
+    elif target_arch == 'arm64':
+        ldflags.extend(['/MACHINE:arm64'])
+    else:
+        ldflags.extend(['/MACHINE:x86'])
 
   static_libraries = {
       'base': {'sources': [
@@ -737,6 +797,7 @@
         'src/gn/parser.cc',
         'src/gn/path_output.cc',
         'src/gn/pattern.cc',
+        'src/gn/rsp_target_writer.cc',
         'src/gn/pool.cc',
         'src/gn/qt_creator_writer.cc',
         'src/gn/resolved_target_data.cc',
@@ -864,6 +925,7 @@
         'src/gn/pointer_set_unittest.cc',
         'src/gn/resolved_target_data_unittest.cc',
         'src/gn/resolved_target_deps_unittest.cc',
+        # 'src/gn/rsp_target_writer_unittest.cc',
         'src/gn/runtime_deps_unittest.cc',
         'src/gn/scope_per_file_provider_unittest.cc',
         'src/gn/scope_unittest.cc',
@@ -957,5 +1019,29 @@
                     platform, host, options, args_list,
                     cflags, ldflags, libflags, include_dirs, libs)
 
+def windows_target_build_arch():
+    target_arch = os.environ.get('Platform')
+    if target_arch in ['x64', 'x86', 'arm64']: return target_arch
+
+    if platform.machine().lower() in ['x86_64', 'amd64']: return 'x64'
+    return 'x86'
+
+def generate_qt_version_header(qtVersion,header):
+  contents = '''// Generated by build/gen.py.
+
+#ifndef QT_GN_VERSION
+#define QT_GN_VERSION "%s"
+#endif
+''' % (qtVersion)
+
+  old_contents = ''
+  if os.path.isfile(header):
+    with open(header, 'r') as f:
+      old_contents = f.read()
+
+  if old_contents != contents:
+    with open(header, 'w') as f:
+      f.write(contents)
+
 if __name__ == '__main__':
   sys.exit(main(sys.argv[1:]))
diff -ur --new-file a/src/gn/binary_target_generator.cc b/src/gn/binary_target_generator.cc
--- a/src/gn/binary_target_generator.cc
+++ b/src/gn/binary_target_generator.cc
@@ -97,6 +97,7 @@
   for (std::size_t i = 0; i < target_->sources().size(); ++i) {
     const auto& source = target_->sources()[i];
     const SourceFile::Type source_type = source.GetType();
+#if 0
     switch (source_type) {
       case SourceFile::SOURCE_CPP:
       case SourceFile::SOURCE_MODULEMAP:
@@ -124,6 +125,7 @@
                     Target::GetStringForOutputType(target_->output_type()) +
                     ". " + source.value() + " is not one of the valid types.");
     }
+#endif
 
     target_->source_types_used().Set(source_type);
   }
diff -ur --new-file a/src/gn/escape.cc b/src/gn/escape.cc
--- a/src/gn/escape.cc
+++ b/src/gn/escape.cc
@@ -239,6 +239,51 @@
   return i;
 }
 
+size_t EscapeStringToString_Command(const std::string_view& str,
+                                    const EscapeOptions& options,
+                                    char* dchp,
+                                    bool* needed_quoting) {
+  std::string dstr;
+  std::string* dest = &dstr;
+  if (str.find_first_of(" \"") == std::string::npos) {
+    // Simple case, don't quote.
+    dest->append(str.data(), str.size());
+  } else {
+      if (!options.inhibit_quoting)
+        dest->push_back('"');
+      for (size_t i = 0; i < str.size(); i++) {
+        // Count backslashes in case they're followed by a quote.
+        size_t backslash_count = 0;
+        while (i < str.size() && str[i] == '\\') {
+          i++;
+          backslash_count++;
+        }
+        if (i == str.size()) {
+          // Backslashes at end of string. Backslash-escape all of them since
+          // they'll be followed by a quote.
+          dest->append(backslash_count * 2, '\\');
+        } else if (str[i] == '"') {
+          // 0 or more backslashes followed by a quote. Backslash-escape the
+          // backslashes, then backslash-escape the quote.
+          dest->append(backslash_count * 2 + 1, '\\');
+          dest->push_back('"');
+        } else {
+          // Non-special Windows character. Add any
+          // backslashes we read previously, these are literals.
+          dest->append(backslash_count, '\\');
+          dest->push_back(str[i]);
+        }
+      }
+
+      if (!options.inhibit_quoting)
+        dest->push_back('"');
+      if (needed_quoting)
+        *needed_quoting = true;
+  }
+  memcpy(dchp, dstr.c_str(), dstr.size());
+  return dstr.size();
+}
+
 // Escapes |str| into |dest| and returns the number of characters written.
 size_t EscapeStringToString(std::string_view str,
                             const EscapeOptions& options,
@@ -278,6 +323,8 @@
       }
     case ESCAPE_NINJA_PREFORMATTED_COMMAND:
       return EscapeStringToString_NinjaPreformatted(str, dest);
+    case ESCAPE_COMMAND:
+      return EscapeStringToString_Command(str, options, dest, needed_quoting);
     default:
       NOTREACHED();
   }
diff -ur --new-file a/src/gn/escape.h b/src/gn/escape.h
--- a/src/gn/escape.h
+++ b/src/gn/escape.h
@@ -7,6 +7,7 @@
 
 #include <iosfwd>
 #include <string_view>
+#include <string>
 
 enum EscapingMode {
   // No escaping.
@@ -36,6 +37,9 @@
   // Parameters use shell quoting and shell escaping of quotes, with ‘"’ and ‘\’
   // being the only special characters.
   ESCAPE_COMPILATION_DATABASE,
+
+  // Like ESCAPE_NINJA_COMMAND but without ninja string escaping
+  ESCAPE_COMMAND,
 };
 
 enum EscapingPlatform {
diff -ur --new-file a/src/gn/ninja_binary_target_writer.cc b/src/gn/ninja_binary_target_writer.cc
--- a/src/gn/ninja_binary_target_writer.cc
+++ b/src/gn/ninja_binary_target_writer.cc
@@ -4,8 +4,8 @@
 
 #include "gn/ninja_binary_target_writer.h"
 
+#include <list>
 #include <sstream>
-
 #include "base/strings/string_util.h"
 #include "gn/builtin_tool.h"
 #include "gn/config_values_extractors.h"
@@ -17,7 +17,9 @@
 #include "gn/ninja_target_command_util.h"
 #include "gn/ninja_utils.h"
 #include "gn/pool.h"
+#include "gn/rsp_target_writer.h"
 #include "gn/settings.h"
+#include "gn/string_output_buffer.h"
 #include "gn/string_utils.h"
 #include "gn/substitution_writer.h"
 #include "gn/target.h"
@@ -54,6 +56,23 @@
   writer.SetResolvedTargetData(GetResolvedTargetData());
   writer.SetNinjaOutputs(ninja_outputs_);
   writer.Run();
+
+  const std::vector<std::string> types = target_->rsp_types();
+  if (!types.empty()) {
+    for (const std::string& str_type : types) {
+      base::FilePath p_file(
+          target_->settings()->build_settings()->GetFullPath(SourceFile(
+              target_->settings()->build_settings()->build_dir().value() +
+              target_->label().name() + "_" + str_type + ".rsp")));
+      StringOutputBuffer storage;
+      std::ostream p_stream(&storage);
+      const RspTargetWriter::Type& type = RspTargetWriter::strToType(str_type);
+      RspTargetWriter p_writer(&writer, target_, type, p_stream);
+      p_writer.Run();
+      if (p_stream.tellp() != std::streampos(0))
+        storage.WriteToFileIfChanged(p_file, nullptr);
+    }
+  }
 }
 
 std::vector<OutputFile>
diff -ur --new-file a/src/gn/ninja_binary_target_writer.h b/src/gn/ninja_binary_target_writer.h
--- a/src/gn/ninja_binary_target_writer.h
+++ b/src/gn/ninja_binary_target_writer.h
@@ -80,6 +80,8 @@
   std::string rule_prefix_;
 
  private:
+  friend class CMakeLinkWriter;
+  friend class RspTargetWriter;
   NinjaBinaryTargetWriter(const NinjaBinaryTargetWriter&) = delete;
   NinjaBinaryTargetWriter& operator=(const NinjaBinaryTargetWriter&) = delete;
 };
diff -ur --new-file a/src/gn/ninja_c_binary_target_writer.cc b/src/gn/ninja_c_binary_target_writer.cc
--- a/src/gn/ninja_c_binary_target_writer.cc
+++ b/src/gn/ninja_c_binary_target_writer.cc
@@ -572,9 +572,16 @@
       target_, tool_, tool_->outputs(), &output_files);
 
   out_ << "build";
-  WriteOutputs(output_files);
 
-  out_ << ": " << rule_prefix_ << tool_->name();
+  if (target_->rsp_types().empty()) {
+    WriteOutputs(output_files);
+    out_ << ": " << rule_prefix_ << tool_->name();
+  } else {
+    out_ << " ";
+    WriteOutput(OutputFile(target_->label().name() + ".stamp"));
+    out_ << ": " << rule_prefix_;
+    out_ << GeneralTool::kGeneralToolStamp << " |";
+  }
 
   ClassifiedDeps classified_deps = GetClassifiedDeps();
 
@@ -673,7 +680,9 @@
 
   // Append implicit dependencies collected above.
   if (!implicit_deps.empty()) {
-    out_ << " |";
+    if (target_->rsp_types().empty()) {
+        out_ << " |";
+    }
     path_output_.WriteFiles(out_, implicit_deps);
   }
 
diff -ur --new-file a/src/gn/ninja_target_writer.cc b/src/gn/ninja_target_writer.cc
--- a/src/gn/ninja_target_writer.cc
+++ b/src/gn/ninja_target_writer.cc
@@ -18,6 +18,7 @@
 #include "gn/ninja_action_target_writer.h"
 #include "gn/ninja_binary_target_writer.h"
 #include "gn/ninja_bundle_data_target_writer.h"
+#include "gn/ninja_c_binary_target_writer.h"
 #include "gn/ninja_copy_target_writer.h"
 #include "gn/ninja_create_bundle_target_writer.h"
 #include "gn/ninja_generated_file_target_writer.h"
diff -ur --new-file a/src/gn/rsp_target_writer.cc b/src/gn/rsp_target_writer.cc
--- /dev/null
+++ b/src/gn/rsp_target_writer.cc
@@ -0,0 +1,255 @@
+/****************************************************************************
+**
+** Copyright (C) 2021 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the QtWebEngine module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "gn/rsp_target_writer.h"
+#include "base/logging.h"
+#include "base/strings/string_util.h"
+#include "gn/config_values_extractors.h"
+#include "gn/deps_iterator.h"
+#include "gn/ninja_c_binary_target_writer.h"
+#include "gn/ninja_target_command_util.h"
+#include "gn/output_file.h"
+#include "gn/resolved_target_data.h"
+#include "gn/settings.h"
+#include "gn/target.h"
+
+RspTargetWriter::RspTargetWriter(const NinjaCBinaryTargetWriter* writer,
+                                 const Target* target,
+                                 Type type,
+                                 std::ostream& out)
+    : type_(type), target_(target), nwriter_(writer), out_(out) {}
+RspTargetWriter::~RspTargetWriter() {}
+
+// Based on similar function in qt_creator_writer.cc
+static void CollectDeps(std::set<const Target*>& deps, const Target* target) {
+  for (const auto& dep : target->GetDeps(Target::DEPS_ALL)) {
+    const Target* dep_target = dep.ptr;
+    if (deps.count(dep_target))
+      continue;
+    deps.insert(dep_target);
+    CollectDeps(deps, dep_target);
+  }
+}
+
+const ResolvedTargetData& RspTargetWriter::resolved() const {
+  if (!resolved_) {
+    resolved_ = std::make_unique<ResolvedTargetData>();
+  }
+  return *resolved_;
+}
+
+void RspTargetWriter::Run() {
+  CHECK(target_->output_type() == Target::SHARED_LIBRARY ||
+        target_->output_type() == Target::STATIC_LIBRARY)
+      << "RspTargetWriter only supports libraries";
+
+  std::vector<SourceFile> other_files;
+  std::vector<OutputFile> tool_outputs;
+  NinjaBinaryTargetWriter::ClassifiedDeps cdeps = nwriter_->GetClassifiedDeps();
+
+  std::set<const Target*> deps;
+  deps.insert(target_);
+  CollectDeps(deps, target_);
+  const Settings* settings = target_->settings();
+  const CTool* tool =
+      target_->toolchain()->GetToolForTargetFinalOutput(target_)->AsC();
+
+  std::string prefix(
+      settings->build_settings()->build_dir().SourceWithNoTrailingSlash());
+  prefix.append("/");
+#if defined(OS_WIN)
+  prefix.erase(prefix.begin());
+#endif
+  switch (type_) {
+    case NONE:
+      return;
+    case DEFINES: {
+      for (const auto& target : deps) {
+        for (ConfigValuesIterator it(target); !it.done(); it.Next()) {
+          for (std::string define : it.cur().defines()) {
+            out_ << define << " ";
+          }
+        }
+      }
+      out_.flush();
+    } break;
+    case OBJECTS: {
+      PathOutput path_output(settings->build_settings()->build_dir(),
+                             settings->build_settings()->root_path_utf8(),
+                             ESCAPE_NONE);
+      std::vector<SourceFile> object_files;
+      object_files.reserve(target_->sources().size());
+
+      for (const auto& source : target_->sources()) {
+        const char* tool_type = nullptr;
+        if (!target_->GetOutputFilesForSource(source, &tool_type,
+                                              &tool_outputs)) {
+          if (source.GetType() == SourceFile::SOURCE_DEF)
+            other_files.push_back(source);
+          continue;  // No output for this source.
+        }
+        object_files.push_back(
+            tool_outputs[0].AsSourceFile(settings->build_settings()));
+      }
+      if (target_->config_values().has_precompiled_headers()) {
+        const CTool* tool_cxx =
+            target_->toolchain()->GetTool(CTool::kCToolCxx)->AsC();
+        if (tool_cxx && tool_cxx->precompiled_header_type() == CTool::PCH_MSVC) {
+          GetPCHOutputFiles(target_, CTool::kCToolCxx, &tool_outputs);
+          if (!tool_outputs.empty())
+            object_files.push_back(
+                tool_outputs[0].AsSourceFile(settings->build_settings()));
+        }
+      }
+      for (const auto& file : object_files) {
+        out_ << "\"" << prefix;
+        path_output.WriteFile(out_, file);
+        out_ << "\"\n";
+      }
+      for (const auto& file : cdeps.extra_object_files) {
+        out_ << "\"" << prefix;
+        path_output.WriteFile(out_, file);
+        out_ << "\"\n";
+      }
+      out_.flush();
+    } break;
+    case LFLAGS: {
+      EscapeOptions opts;
+      opts.mode = ESCAPE_COMMAND;
+      // First the ldflags from the target and its config.
+      RecursiveTargetConfigStringsToStream(kRecursiveWriterKeepDuplicates,
+                                           target_, &ConfigValues::ldflags,
+                                           opts, out_);
+      out_.flush();
+    } break;
+    case LDIR: {
+      // library dirs
+      const auto& all_lib_dirs = resolved().GetLinkedLibraryDirs(target_);
+      if (!all_lib_dirs.empty()) {
+        PathOutput lib_path_output(settings->build_settings()->build_dir(),
+                                   settings->build_settings()->root_path_utf8(),
+                                   ESCAPE_COMMAND);
+        for (size_t i = 0; i < all_lib_dirs.size(); i++) {
+          out_ << " -L\"";
+          lib_path_output.WriteDir(out_, all_lib_dirs[i],
+                                   PathOutput::DIR_NO_LAST_SLASH);
+          out_ << "\"";
+        }
+        out_.flush();
+      }
+    } break;
+    case ARCHIVES: {
+      PathOutput path_output(settings->build_settings()->build_dir(),
+                             settings->build_settings()->root_path_utf8(),
+                             ESCAPE_NONE);
+      std::vector<OutputFile> solibs;
+      for (const Target* cur : cdeps.linkable_deps) {
+        if (cur->dependency_output_file().value() !=
+            cur->link_output_file().value()) {
+          LOG(ERROR) << "Dependency output file name does not match "
+                        "link output file name:\n" <<
+                        cur->dependency_output_file().value() <<
+                        " vs " <<
+                        cur->link_output_file().value();
+          solibs.push_back(cur->link_output_file());
+        } else {
+          out_ << "\"" << prefix;
+          path_output.WriteFile(out_, cur->link_output_file());
+          out_ << "\"\n";
+        }
+      }
+      out_.flush();
+
+      CHECK(solibs.empty()) << "Unhandled solibs";
+    } break;
+    case LIBS: {
+      EscapeOptions lib_escape_opts;
+      lib_escape_opts.mode = ESCAPE_COMMAND;
+
+      const auto& all_libs = resolved().GetLinkedLibraries(target_);
+      const std::string framework_ending(".framework");
+      for (size_t i = 0; i < all_libs.size(); i++) {
+        const LibFile& lib_file = all_libs[i];
+        const std::string& lib_value = lib_file.value();
+        if (lib_file.is_source_file()) {
+          PathOutput lib_path_output(
+              settings->build_settings()->build_dir(),
+              settings->build_settings()->root_path_utf8(), ESCAPE_COMMAND);
+          out_ << "\"";
+          lib_path_output.WriteFile(out_, lib_file.source_file());
+          out_ << "\"";
+        } else {
+          out_ << " " << tool->lib_switch();
+          EscapeStringToStream(out_, lib_value, lib_escape_opts);
+        }
+      }
+      FrameworksWriter writer(tool->framework_switch());
+      const auto& all_frameworks = resolved().GetLinkedFrameworks(target_);
+      for (size_t i = 0; i < all_frameworks.size(); i++) {
+        writer(all_frameworks[i], out_);
+      }
+      FrameworksWriter weak_writer(tool->weak_framework_switch());
+      const auto& all_weak_frameworks =
+          resolved().GetLinkedWeakFrameworks(target_);
+      for (size_t i = 0; i < all_weak_frameworks.size(); i++) {
+        weak_writer(all_weak_frameworks[i], out_);
+      }
+      out_.flush();
+    }
+  }
+}
+
+RspTargetWriter::Type RspTargetWriter::strToType(const std::string& str) {
+  static std::unordered_map<std::string, RspTargetWriter::Type> const types = {
+      {"objects", RspTargetWriter::OBJECTS},
+      {"archives", RspTargetWriter::ARCHIVES},
+      {"defines", RspTargetWriter::DEFINES},
+      {"lflags", RspTargetWriter::LFLAGS},
+      {"libs", RspTargetWriter::LIBS},
+      {"ldir", RspTargetWriter::LDIR}};
+  auto it = types.find(str);
+  if (it != types.end()) {
+    return it->second;
+  }
+  return RspTargetWriter::NONE;
+}
diff -ur --new-file a/src/gn/rsp_target_writer.h b/src/gn/rsp_target_writer.h
--- /dev/null
+++ b/src/gn/rsp_target_writer.h
@@ -0,0 +1,71 @@
+/****************************************************************************
+**
+** Copyright (C) 2021 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the QtWebEngine module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef TOOLS_GN_RSP_TARGET_WRITER_H_
+#define TOOLS_GN_RSP_TARGET_WRITER_H_
+
+#include <iosfwd>
+#include <memory>
+#include "gn/path_output.h"
+
+class Target;
+class NinjaCBinaryTargetWriter;
+class ResolvedTargetData;
+
+class RspTargetWriter {
+ public:
+  enum Type { NONE, OBJECTS, ARCHIVES, DEFINES, LFLAGS, LIBS, LDIR};
+  RspTargetWriter(const NinjaCBinaryTargetWriter* writer,
+                  const Target* target,
+                  Type type,
+                  std::ostream& out);
+  ~RspTargetWriter();
+  void Run();
+  static Type strToType(const std::string& str);
+  const ResolvedTargetData& resolved() const;
+
+ private:
+  Type type_;
+  const Target* target_;
+  const NinjaCBinaryTargetWriter* nwriter_;
+  std::ostream& out_;
+  mutable std::unique_ptr<ResolvedTargetData> resolved_;
+};
+
+#endif  // TOOLS_GN_RSP_TARGET_WRITER_H_
diff -ur --new-file a/src/gn/scope_per_file_provider.cc b/src/gn/scope_per_file_provider.cc
--- a/src/gn/scope_per_file_provider.cc
+++ b/src/gn/scope_per_file_provider.cc
@@ -12,7 +12,11 @@
 #include "gn/value.h"
 #include "gn/variables.h"
 
+#ifndef NO_LAST_COMMIT_POSITION
 #include "last_commit_position.h"
+#else
+#define LAST_COMMIT_POSITION_NUM 0
+#endif
 
 ScopePerFileProvider::ScopePerFileProvider(Scope* scope, bool allow_target_vars)
     : ProgrammaticProvider(scope), allow_target_vars_(allow_target_vars) {}
diff -ur --new-file a/src/gn/target.cc b/src/gn/target.cc
--- a/src/gn/target.cc
+++ b/src/gn/target.cc
@@ -882,6 +882,9 @@
       link_output_file_ = dependency_output_file_ =
           SubstitutionWriter::ApplyPatternToLinkerAsOutputFile(
               this, tool, tool->outputs().list()[0]);
+      if (!rsp_types().empty()) {
+          dependency_output_file_ = OutputFile(label().name() + ".stamp");
+      }
       break;
     case RUST_PROC_MACRO:
     case SHARED_LIBRARY: {
@@ -932,6 +935,9 @@
         SubstitutionWriter::ApplyListToLinkerAsOutputFile(
             this, tool, *runtime_outputs_ptr, &runtime_outputs_);
       }
+      if (!rsp_types().empty()) {
+          dependency_output_file_ = OutputFile(label().name() + ".stamp");
+      }
       break;
     }
     case UNKNOWN:
diff -ur --new-file a/src/gn/target_generator.cc b/src/gn/target_generator.cc
--- a/src/gn/target_generator.cc
+++ b/src/gn/target_generator.cc
@@ -58,6 +58,9 @@
   if (!FillTestonly())
     return;
 
+  if (!FillRspTypes())
+    return;
+
   if (!FillAssertNoDeps())
     return;
 
@@ -312,6 +315,27 @@
   }
   return true;
 }
+
+bool TargetGenerator::FillRspTypes() {
+  const Value* value = scope_->GetValue(variables::kRspTypes, true);
+  if (!value)
+    return true;
+  if (!value->VerifyTypeIs(Value::LIST, err_))
+    return false;
+
+  const std::vector<Value>& value_list = value->list_value();
+  std::vector<std::string>& rsp_types = target_->rsp_types();
+  rsp_types.reserve(value_list.size());
+
+  for (size_t i = 0; i < value_list.size(); i++) {
+    const Value& v = value_list[i];
+    if (!v.VerifyTypeIs(Value::STRING, err_))
+      return false;
+    const std::string str = v.string_value();
+    rsp_types.push_back(str);
+  }
+  return true;
+}
 
 bool TargetGenerator::FillAssertNoDeps() {
   const Value* value = scope_->GetValue(variables::kAssertNoDeps, true);
diff -ur --new-file a/src/gn/target_generator.h b/src/gn/target_generator.h
--- a/src/gn/target_generator.h
+++ b/src/gn/target_generator.h
@@ -70,6 +70,7 @@
   bool FillDependencies();  // Includes data dependencies.
   bool FillMetadata();
   bool FillTestonly();
+  bool FillRspTypes();
   bool FillAssertNoDeps();
   bool FillWriteRuntimeDeps();
 
diff -ur --new-file a/src/gn/target.h b/src/gn/target.h
--- a/src/gn/target.h
+++ b/src/gn/target.h
@@ -190,6 +190,7 @@
     SourceDir rebase_;
     std::vector<std::string> data_keys_;
     std::vector<std::string> walk_keys_;
+    std::vector<std::string> rsp_types_;
   };
   const GeneratedFile& generated_file() const;
   GeneratedFile& generated_file();
@@ -215,6 +216,9 @@
   }
   std::vector<std::string>& walk_keys() { return generated_file().walk_keys_; }
 
+  std::vector<std::string>& rsp_types() { return generated_file().rsp_types_; }
+  const std::vector<std::string>& rsp_types() const { return generated_file().rsp_types_; }
+
   OutputFile write_runtime_deps_output() const {
     return write_runtime_deps_output_;
   }
diff -ur --new-file a/src/gn/variables.cc b/src/gn/variables.cc
--- a/src/gn/variables.cc
+++ b/src/gn/variables.cc
@@ -2229,6 +2229,30 @@
   }
 )";
 
+const char kRspTypes[] = "rsp_types";
+const char kRspTypes_HelpShort[] =
+    "rsp_types: [string list] A list of rsp files to create wih linker "
+    "information for given target.";
+const char kRspTypes_Help[] =
+    "rsp_types: Declares a target that instead of liking dumps the information "
+    "to set of rsp files.\n"
+    "\n"
+    "  Defaults to ["
+    "].\n"
+    "\n"
+    "  When a target is marked \"rsp_types = [ \"objects\" , \"archives\" ... "
+    "]\" and is linkable,"
+    "  the linking step  is skipped. Instead linking infomation is dumped as a "
+    "set of responses file containing"
+    "  selected types of information\n"
+    "\n"
+    "Example\n"
+    "\n"
+    "  static_library(\"test_support\") {\n"
+    "    rsp_types = \"libs\"\n"
+    "    ...\n"
+    "  }\n";
+
 const char kVisibility[] = "visibility";
 const char kVisibility_HelpShort[] =
     "visibility: [label list] A list of labels that can depend on a target.";
diff -ur --new-file a/src/gn/variables.h b/src/gn/variables.h
--- a/src/gn/variables.h
+++ b/src/gn/variables.h
@@ -346,6 +346,10 @@
 extern const char kTestonly_HelpShort[];
 extern const char kTestonly_Help[];
 
+extern const char kRspTypes[];
+extern const char kRspTypes_HelpShort[];
+extern const char kRspTypes_Help[];
+
 extern const char kVisibility[];
 extern const char kVisibility_HelpShort[];
 extern const char kVisibility_Help[];
diff -ur --new-file a/src/util/build_config.h b/src/util/build_config.h
--- a/src/util/build_config.h
+++ b/src/util/build_config.h
@@ -135,7 +135,7 @@
 #define ARCH_CPU_ARMEL 1
 #define ARCH_CPU_32_BITS 1
 #define ARCH_CPU_LITTLE_ENDIAN 1
-#elif defined(__aarch64__)
+#elif defined(__aarch64__) || defined(_M_ARM64)
 #define ARCH_CPU_ARM_FAMILY 1
 #define ARCH_CPU_ARM64 1
 #define ARCH_CPU_64_BITS 1
diff -ur --new-file a/src/util/sys_info.cc b/src/util/sys_info.cc
--- a/src/util/sys_info.cc
+++ b/src/util/sys_info.cc
@@ -87,6 +87,8 @@
       return "x86";
     case PROCESSOR_ARCHITECTURE_AMD64:
       return "x86_64";
+    case PROCESSOR_ARCHITECTURE_ARM64:
+      return "arm64";
     case PROCESSOR_ARCHITECTURE_IA64:
       return "ia64";
   }
