diff --git a/gn/build/build_clang_cl.ninja.template b/build/build_clang_cl.ninja.template
new file mode 100644
--- /dev/null
+++ b/build/build_clang_cl.ninja.template
@@ -0,0 +1,12 @@
+rule cxx
+  command = $cxx /nologo /showIncludes /FC $includes $cflags /c $in /Fo$out
+  description = CXX $out
+  deps = msvc
+
+rule alink_thin
+  command = $ar /nologo /ignore:4221 $libflags /OUT:$out $in
+  description = LIB $out
+
+rule link
+  command = $ld /nologo $ldflags /OUT:$out /PDB:$out.pdb $in $solibs $libs
+  description = LINK $out
diff --git a/gn/build/build_mingw.ninja.template b/build/build_mingw.ninja.template
new file mode 100644
--- /dev/null
+++ b/build/build_mingw.ninja.template
@@ -0,0 +1,13 @@
+rule cxx
+  command = $cxx -MMD -MF $out.d $includes $cflags -c $in -o $out
+  description = CXX $out
+  depfile = $out.d
+  deps = gcc
+
+rule alink_thin
+  command = cmd /c del $out && $ar rcsT $out $in
+  description = AR $out
+
+rule link
+  command = $ld $ldflags -o $out -Wl,--start-group $in $libs -Wl,--end-group $solibs
+  description = LINK $out
diff --git a/build/build_win.ninja.template b/build/build_win.ninja.template
--- a/build/build_win.ninja.template
+++ b/build/build_win.ninja.template
@@ -8,5 +8,5 @@ rule alink_thin
   description = LIB $out
 
 rule link
-  command = $ld /nologo $ldflags /OUT:$out /PDB:$out.pdb $in $solibs $libs
+  command = $ld /nologo $in /link $ldflags /PDB:$out.pdb /OUT:$out $solibs $libs
   description = LINK $out
diff --git a/build/gen.py b/build/gen.py
--- a/build/gen.py
+++ b/build/gen.py
@@ -200,6 +200,24 @@ def main(argv):
   args_list.add('--allow-warnings', action='store_true', default=False,
                     help=('Allow compiler warnings, don\'t treat them as '
                           'errors.'))
+  args_list.add('--cc',
+                    help='The path to cc compiler.')
+  args_list.add('--cxx',
+                    help='The path to cxx compiler.')
+  args_list.add('--ld',
+                    help='The path to ld.')
+  args_list.add('--ar',
+                    help='The path to ar.')
+  args_list.add('--isysroot',
+                    help='The path to the macOS SDK sysroot to be used.')
+  args_list.add('--qt-version',
+                    help="The qt version gn is compiled for.")
+  args_list.add('--osx-architectures',
+                    help='delimited list of architectures for universal build',
+                    type=str)
+  args_list.add('--gcc-legacy-support', action='store_true',
+                    help='Support gcc9 compilation')
+
   if sys.platform == 'zos':
     args_list.add('--zoslib-dir',
                       action='store',
@@ -225,6 +242,9 @@ def main(argv):
   if not options.no_last_commit_position:
     GenerateLastCommitPosition(host,
                                os.path.join(out_dir, 'last_commit_position.h'))
+  if options.qt_version:
+      generate_qt_version_header(options.qt_version, os.path.join(out_dir, 'qt_version.h'))
+
   WriteGNNinja(os.path.join(out_dir, 'build.ninja'), platform, host, options, args_list)
   return 0
 
@@ -295,10 +315,15 @@ def WriteGenericNinja(path, static_libraries, executables,
     '',
   ]
 
+  platform_template = platform.platform()
+
+  if "clang-cl" in cxx:
+     platform_template = "clang-cl"
 
   template_filename = os.path.join(SCRIPT_DIR, {
       'msvc': 'build_win.ninja.template',
-      'mingw': 'build_linux.ninja.template',
+      'mingw': 'build_mingw.ninja.template',
+      'clang-cl': 'build_clang_cl.ninja.template',
       'msys': 'build_linux.ninja.template',
       'darwin': 'build_mac.ninja.template',
       'linux': 'build_linux.ninja.template',
@@ -310,7 +335,7 @@ def WriteGenericNinja(path, static_libraries, executables,
       'netbsd': 'build_linux.ninja.template',
       'zos': 'build_zos.ninja.template',
       'serenity': 'build_linux.ninja.template',
-  }[platform.platform()])
+  }[platform_template])
 
   with open(template_filename) as f:
     ninja_template = f.read()
@@ -391,27 +416,46 @@ def WriteGenericNinja(path, static_libraries, executables,
 
 
 def WriteGNNinja(path, platform, host, options, args_list):
-  if platform.is_msvc():
-    cxx = os.environ.get('CXX', 'cl.exe')
-    ld = os.environ.get('LD', 'link.exe')
-    ar = os.environ.get('AR', 'lib.exe')
-  elif platform.is_aix():
-    cxx = os.environ.get('CXX', 'g++')
-    ld = os.environ.get('LD', 'g++')
-    ar = os.environ.get('AR', 'ar -X64')
-  elif platform.is_msys() or platform.is_mingw():
-    cxx = os.environ.get('CXX', 'g++')
-    ld = os.environ.get('LD', 'g++')
-    ar = os.environ.get('AR', 'ar')
-  else:
-    cxx = os.environ.get('CXX', 'clang++')
-    ld = cxx
-    ar = os.environ.get('AR', 'ar')
-
-  cflags = os.environ.get('CFLAGS', '').split()
-  cflags += os.environ.get('CXXFLAGS', '').split()
-  ldflags = os.environ.get('LDFLAGS', '').split()
-  libflags = os.environ.get('LIBFLAGS', '').split()
+  # QTBUG-64759
+  # if platform.is_msvc():
+  #   cxx = os.environ.get('CXX', 'cl.exe')
+  #   ld = os.environ.get('LD', 'link.exe')
+  #   ar = os.environ.get('AR', 'lib.exe')
+  # elif platform.is_aix():
+  #   cxx = os.environ.get('CXX', 'g++')
+  #   ld = os.environ.get('LD', 'g++')
+  #   ar = os.environ.get('AR', 'ar -X64')
+  # elif platform.is_msys() or platform.is_mingw():
+  #   cxx = os.environ.get('CXX', 'g++')
+  #   ld = os.environ.get('LD', 'g++')
+  #   ar = os.environ.get('AR', 'ar')
+  # else:
+  #   cxx = os.environ.get('CXX', 'c++')
+  #  ld = cxx
+  #  ar = os.environ.get('AR', 'ar')
+
+
+  # cflags = os.environ.get('CFLAGS', '').split()
+  # cflags += os.environ.get('CXXFLAGS', '').split()
+  # ldflags = os.environ.get('LDFLAGS', '').split()
+  # libflags = os.environ.get('LIBFLAGS', '').split()
+
+  cflags = []
+  cflags_cc = []
+  ldflags = []
+  libflags = []
+
+  cc = options.cc
+  cxx = options.cxx
+  ld = options.ld
+  ar = options.ar
+
+  if not ar:
+     if platform.is_msvc():
+        ar = os.environ.get('AR', 'lib.exe')
+     else:
+        ar = os.environ.get('AR', 'ar')
+
   include_dirs = [
       os.path.relpath(os.path.join(REPO_ROOT, 'src'), os.path.dirname(path)),
       '.',
@@ -421,6 +465,9 @@ def WriteGNNinja(path, platform, host, options, args_list):
 
   libs = []
 
+  if options.no_last_commit_position:
+      cflags.append('-DNO_LAST_COMMIT_POSITION')
+
   if not platform.is_msvc():
     if options.debug:
       cflags.extend(['-O0', '-g'])
@@ -436,6 +483,10 @@ def WriteGNNinja(path, platform, host, options, args_list):
       if options.no_strip:
         cflags.append('-g')
       ldflags.append('-O3')
+      if platform.is_darwin() and options.isysroot:
+        cflags.append('-isysroot ' +  options.isysroot)
+        ldflags.append('-isysroot ' +  options.isysroot)
+
       # Use -fdata-sections and -ffunction-sections to place each function
       # or data item into its own section so --gc-sections can eliminate any
       # unused functions and data items.
@@ -510,20 +561,32 @@ def WriteGNNinja(path, platform, host, options, args_list):
       if not options.no_static_libstdcpp:
         ldflags.append('-static-libstdc++')
 
+      cflags.remove('-std=c++20')
       cflags.extend([
         '-Wno-deprecated-copy',
         '-Wno-implicit-fallthrough',
         '-Wno-redundant-move',
         '-Wno-unused-variable',
+        '-Wno-parentheses-equality',
         '-Wno-format',             # Use of %llx, which is supported by _UCRT, false positive
         '-Wno-strict-aliasing',    # Dereferencing punned pointer
         '-Wno-cast-function-type', # Casting FARPROC to RegDeleteKeyExPtr
       ])
 
+      if options.gcc_legacy_support:
+        cflags.append('-std=gnu++2a')
+      else:
+        cflags.append('-std=gnu++20')
+
     elif platform.is_darwin():
       min_mac_version_flag = '-mmacosx-version-min=10.9'
       cflags.append(min_mac_version_flag)
       ldflags.append(min_mac_version_flag)
+      if options.osx_architectures:
+         arch_list = [str(arch) for arch in options.osx_architectures.split(',')]
+         for arch in arch_list:
+           cflags.extend(['-arch',arch])
+           ldflags.extend(['-arch',arch])
     elif platform.is_aix():
       cflags.append('-maix64')
       ldflags.append('-maix64')
@@ -584,6 +647,7 @@ def WriteGNNinja(path, platform, host, options, args_list):
         '/wd4244',
         '/wd4267',
         '/wd4505',
+        '/wd4577',
         '/wd4838',
         '/wd4996',
         '/std:c++20',
@@ -593,8 +657,15 @@ def WriteGNNinja(path, platform, host, options, args_list):
 
     win_manifest = os.path.relpath(
       os.path.join(REPO_ROOT, "build/windows.manifest.xml"), options.out_path)
-    ldflags.extend(['/DEBUG', '/MACHINE:x64', '/MANIFEST:EMBED',
+    ldflags.extend(['/DEBUG', '/MANIFEST:EMBED',
                     f'/MANIFESTINPUT:{win_manifest}'])
+    target_arch = windows_target_build_arch()
+    if target_arch == 'x64':
+        ldflags.extend(['/MACHINE:x64'])
+    elif target_arch == 'arm64':
+        ldflags.extend(['/MACHINE:arm64'])
+    else:
+        ldflags.extend(['/MACHINE:x86'])
 
   static_libraries = {
       'base': {'sources': [
@@ -737,6 +808,7 @@ def WriteGNNinja(path, platform, host, options, args_list):
         'src/gn/parser.cc',
         'src/gn/path_output.cc',
         'src/gn/pattern.cc',
+        'src/gn/rsp_target_writer.cc',
         'src/gn/pool.cc',
         'src/gn/qt_creator_writer.cc',
         'src/gn/resolved_target_data.cc',
@@ -864,6 +936,7 @@ def WriteGNNinja(path, platform, host, options, args_list):
         'src/gn/pointer_set_unittest.cc',
         'src/gn/resolved_target_data_unittest.cc',
         'src/gn/resolved_target_deps_unittest.cc',
+        'src/gn/rsp_target_writer_unittest.cc',
         'src/gn/runtime_deps_unittest.cc',
         'src/gn/scope_per_file_provider_unittest.cc',
         'src/gn/scope_unittest.cc',
@@ -957,5 +1030,29 @@ def WriteGNNinja(path, platform, host, options, args_list):
                     platform, host, options, args_list,
                     cflags, ldflags, libflags, include_dirs, libs)
 
+def windows_target_build_arch():
+    target_arch = os.environ.get('Platform')
+    if target_arch in ['x64', 'x86', 'arm64']: return target_arch
+
+    if platform.machine().lower() in ['x86_64', 'amd64']: return 'x64'
+    return 'x86'
+
+def generate_qt_version_header(qtVersion,header):
+  contents = '''// Generated by build/gen.py.
+
+#ifndef QT_GN_VERSION
+#define QT_GN_VERSION "%s"
+#endif
+''' % (qtVersion)
+
+  old_contents = ''
+  if os.path.isfile(header):
+    with open(header, 'r') as f:
+      old_contents = f.read()
+
+  if old_contents != contents:
+    with open(header, 'w') as f:
+      f.write(contents)
+
 if __name__ == '__main__':
   sys.exit(main(sys.argv[1:]))
diff --git a/src/gn/binary_target_generator.cc b/src/gn/binary_target_generator.cc
--- a/src/gn/binary_target_generator.cc
+++ b/src/gn/binary_target_generator.cc
@@ -97,6 +97,7 @@ bool BinaryTargetGenerator::FillSources() {
   for (std::size_t i = 0; i < target_->sources().size(); ++i) {
     const auto& source = target_->sources()[i];
     const SourceFile::Type source_type = source.GetType();
+#if 0
     switch (source_type) {
       case SourceFile::SOURCE_CPP:
       case SourceFile::SOURCE_MODULEMAP:
@@ -124,6 +125,7 @@ bool BinaryTargetGenerator::FillSources() {
                     Target::GetStringForOutputType(target_->output_type()) +
                     ". " + source.value() + " is not one of the valid types.");
     }
+#endif
 
     target_->source_types_used().Set(source_type);
   }
diff --git a/src/gn/command_format_unittest.cc b/src/gn/command_format_unittest.cc
--- a/src/gn/command_format_unittest.cc
+++ b/src/gn/command_format_unittest.cc
@@ -20,8 +20,12 @@ using FormatTest = TestWithScheduler;
     std::string input;                                                      \
     std::string out;                                                        \
     std::string expected;                                                   \
-    base::FilePath src_dir =                                                \
-        GetExePath().DirName().Append(FILE_PATH_LITERAL(".."));             \
+    const char* test_data_ptr = getenv("GN_TESTDATA_ROOT");                 \
+    base::FilePath src_dir;                                                 \
+    if (!test_data_ptr)                                                     \
+      src_dir = GetExePath().DirName().Append(FILE_PATH_LITERAL(".."));     \
+    else                                                                    \
+      src_dir = base::FilePath(test_data_ptr);                              \
     base::SetCurrentDirectory(src_dir);                                     \
     ASSERT_TRUE(base::ReadFileToString(                                     \
         base::FilePath(FILE_PATH_LITERAL("src/gn/format_test_data/")        \
diff --git a/src/gn/command_refs.cc b/src/gn/command_refs.cc
--- a/src/gn/command_refs.cc
+++ b/src/gn/command_refs.cc
@@ -226,6 +226,70 @@ size_t DoDirectListOutput(
   return results.size();
 }
 
+size_t RecursivePrintTargetDepsMatch(const DepMap& dep_map,
+                                     const Target* target,
+                                     const Target* match,
+                                     TargetSet* seen_targets,
+                                     int indent_level);
+
+size_t RecursivePrintTargetMatch(const DepMap& dep_map,
+                                 const Target* target,
+                                 const Target* match,
+                                 TargetSet* seen_targets,
+                                 int indent_level) {
+  size_t count = 0;
+
+  if (seen_targets->add(target)) {
+    count += RecursivePrintTargetDepsMatch(dep_map, target, match, seen_targets,
+                                           indent_level + 1);
+  }
+  if (target == match) {
+    count = 1;
+  }
+  if (count > 0) {
+    std::string indent(indent_level * 2, ' ');
+    OutputString(indent);
+    if (target == match)
+      OutputString(">>> ");
+    OutputString(
+        target->label().GetUserVisibleName(!target->settings()->is_default()));
+    OutputString("\n");
+  }
+  return count;
+}
+
+size_t RecursivePrintTargetDepsMatch(const DepMap& dep_map,
+                                     const Target* target,
+                                     const Target* match,
+                                     TargetSet* seen_targets,
+                                     int indent_level) {
+  DepMap::const_iterator dep_begin = dep_map.lower_bound(target);
+  DepMap::const_iterator dep_end = dep_map.upper_bound(target);
+  size_t count = 0;
+  for (DepMap::const_iterator cur_dep = dep_begin; cur_dep != dep_end;
+       cur_dep++) {
+    count += RecursivePrintTargetMatch(dep_map, cur_dep->second, match,
+                                       seen_targets, indent_level);
+  }
+  return count;
+}
+
+size_t DoFilteredTreeOutput(
+    const DepMap& dep_map,
+    const Target* match,
+    const UniqueVector<const Target*>& implicit_target_matches,
+    const UniqueVector<const Target*>& explicit_target_matches) {
+  TargetSet seen_targets;
+  size_t count = 0;
+  for (const Target* target : implicit_target_matches) {
+    if (target == match)
+      continue;
+    count +=
+        RecursivePrintTargetMatch(dep_map, target, match, &seen_targets, 0);
+  }
+  return count;
+}
+
 }  // namespace
 
 const char kRefs[] = "refs";
@@ -349,6 +413,7 @@ int RunRefs(const std::vector<std::string>& args) {
   const base::CommandLine* cmdline = base::CommandLine::ForCurrentProcess();
   bool tree = cmdline->HasSwitch("tree");
   bool all = cmdline->HasSwitch("all");
+  bool tree_match = cmdline->HasSwitch("tree-match");
   bool default_toolchain_only = cmdline->HasSwitch(switches::kDefaultToolchain);
 
   // Deliberately leaked to avoid expensive process teardown.
@@ -431,13 +496,17 @@ int RunRefs(const std::vector<std::string>& args) {
   FillDepMap(setup, &dep_map);
 
   size_t cnt = 0;
-  if (tree)
+  if (tree_match) {
+    const Target* target = target_matches[0];
+    cnt = DoFilteredTreeOutput(dep_map, target, target_matches,
+                               explicit_target_matches);
+  } else if (tree) {
     cnt = DoTreeOutput(dep_map, target_matches, explicit_target_matches, all);
-  else if (all)
+  } else if (all) {
     cnt = DoAllListOutput(dep_map, target_matches, explicit_target_matches);
-  else
+  } else {
     cnt = DoDirectListOutput(dep_map, target_matches, explicit_target_matches);
-
+  }
   // If you ask for the references of a valid target, but that target has
   // nothing referencing it, we'll get here without having printed anything.
   if (!quiet && cnt == 0)
diff --git a/src/gn/escape.cc b/src/gn/escape.cc
--- a/src/gn/escape.cc
+++ b/src/gn/escape.cc
@@ -239,6 +239,51 @@ size_t EscapeStringToString_PosixNinjaFork(std::string_view str,
   return i;
 }
 
+size_t EscapeStringToString_Command(const std::string_view& str,
+                                    const EscapeOptions& options,
+                                    char* dchp,
+                                    bool* needed_quoting) {
+  std::string dstr;
+  std::string* dest = &dstr;
+  if (str.find_first_of(" \"") == std::string::npos) {
+    // Simple case, don't quote.
+    dest->append(str.data(), str.size());
+  } else {
+      if (!options.inhibit_quoting)
+        dest->push_back('"');
+      for (size_t i = 0; i < str.size(); i++) {
+        // Count backslashes in case they're followed by a quote.
+        size_t backslash_count = 0;
+        while (i < str.size() && str[i] == '\\') {
+          i++;
+          backslash_count++;
+        }
+        if (i == str.size()) {
+          // Backslashes at end of string. Backslash-escape all of them since
+          // they'll be followed by a quote.
+          dest->append(backslash_count * 2, '\\');
+        } else if (str[i] == '"') {
+          // 0 or more backslashes followed by a quote. Backslash-escape the
+          // backslashes, then backslash-escape the quote.
+          dest->append(backslash_count * 2 + 1, '\\');
+          dest->push_back('"');
+        } else {
+          // Non-special Windows character. Add any
+          // backslashes we read previously, these are literals.
+          dest->append(backslash_count, '\\');
+          dest->push_back(str[i]);
+        }
+      }
+
+      if (!options.inhibit_quoting)
+        dest->push_back('"');
+      if (needed_quoting)
+        *needed_quoting = true;
+  }
+  memcpy(dchp, dstr.c_str(), dstr.size());
+  return dstr.size();
+}
+
 // Escapes |str| into |dest| and returns the number of characters written.
 size_t EscapeStringToString(std::string_view str,
                             const EscapeOptions& options,
@@ -278,6 +323,8 @@ size_t EscapeStringToString(std::string_view str,
       }
     case ESCAPE_NINJA_PREFORMATTED_COMMAND:
       return EscapeStringToString_NinjaPreformatted(str, dest);
+    case ESCAPE_COMMAND:
+      return EscapeStringToString_Command(str, options, dest, needed_quoting);
     default:
       NOTREACHED();
   }
diff --git a/src/gn/escape.h b/src/gn/escape.h
--- a/src/gn/escape.h
+++ b/src/gn/escape.h
@@ -7,6 +7,7 @@
 
 #include <iosfwd>
 #include <string_view>
+#include <string>
 
 enum EscapingMode {
   // No escaping.
@@ -36,6 +37,9 @@ enum EscapingMode {
   // Parameters use shell quoting and shell escaping of quotes, with ‘"’ and ‘\’
   // being the only special characters.
   ESCAPE_COMPILATION_DATABASE,
+
+  // Like ESCAPE_NINJA_COMMAND but without ninja string escaping
+  ESCAPE_COMMAND,
 };
 
 enum EscapingPlatform {
diff --git a/src/gn/gn_main.cc b/src/gn/gn_main.cc
--- a/src/gn/gn_main.cc
+++ b/src/gn/gn_main.cc
@@ -16,7 +16,7 @@
 #include "util/msg_loop.h"
 #include "util/sys_info.h"
 
-#include "last_commit_position.h"
+#include "qt_version.h"
 
 namespace {
 
@@ -49,7 +49,7 @@ int main(int argc, char** argv) {
     command = commands::kHelp;
   } else if (cmdline.HasSwitch(switches::kVersion)) {
     // Make "--version" print the version and exit.
-    OutputString(std::string(LAST_COMMIT_POSITION) + "\n");
+    OutputString(std::string(QT_GN_VERSION) +"\n");
     exit(0);
   } else if (args.empty()) {
     // No command, print error and exit.
diff --git a/src/gn/ninja_binary_target_writer.cc b/src/gn/ninja_binary_target_writer.cc
--- a/src/gn/ninja_binary_target_writer.cc
+++ b/src/gn/ninja_binary_target_writer.cc
@@ -4,8 +4,8 @@
 
 #include "gn/ninja_binary_target_writer.h"
 
+#include <list>
 #include <sstream>
-
 #include "base/strings/string_util.h"
 #include "gn/builtin_tool.h"
 #include "gn/config_values_extractors.h"
@@ -17,7 +17,9 @@
 #include "gn/ninja_target_command_util.h"
 #include "gn/ninja_utils.h"
 #include "gn/pool.h"
+#include "gn/rsp_target_writer.h"
 #include "gn/settings.h"
+#include "gn/string_output_buffer.h"
 #include "gn/string_utils.h"
 #include "gn/substitution_writer.h"
 #include "gn/target.h"
@@ -54,6 +56,23 @@ void NinjaBinaryTargetWriter::Run() {
   writer.SetResolvedTargetData(GetResolvedTargetData());
   writer.SetNinjaOutputs(ninja_outputs_);
   writer.Run();
+
+  const std::vector<std::string> types = target_->rsp_types();
+  if (!types.empty()) {
+    for (const std::string& str_type : types) {
+      base::FilePath p_file(
+          target_->settings()->build_settings()->GetFullPath(SourceFile(
+              target_->settings()->build_settings()->build_dir().value() +
+              target_->label().name() + "_" + str_type + ".rsp")));
+      StringOutputBuffer storage;
+      std::ostream p_stream(&storage);
+      const RspTargetWriter::Type& type = RspTargetWriter::strToType(str_type);
+      RspTargetWriter p_writer(&writer, target_, type, p_stream);
+      p_writer.Run();
+      if (p_stream.tellp() != std::streampos(0))
+        storage.WriteToFileIfChanged(p_file, nullptr);
+    }
+  }
 }
 
 std::vector<OutputFile>
diff --git a/src/gn/ninja_binary_target_writer.h b/src/gn/ninja_binary_target_writer.h
--- a/src/gn/ninja_binary_target_writer.h
+++ b/src/gn/ninja_binary_target_writer.h
@@ -80,6 +80,8 @@ class NinjaBinaryTargetWriter : public NinjaTargetWriter {
   std::string rule_prefix_;
 
  private:
+  friend class CMakeLinkWriter;
+  friend class RspTargetWriter;
   NinjaBinaryTargetWriter(const NinjaBinaryTargetWriter&) = delete;
   NinjaBinaryTargetWriter& operator=(const NinjaBinaryTargetWriter&) = delete;
 };
diff --git a/src/gn/ninja_c_binary_target_writer.cc b/src/gn/ninja_c_binary_target_writer.cc
--- a/src/gn/ninja_c_binary_target_writer.cc
+++ b/src/gn/ninja_c_binary_target_writer.cc
@@ -572,9 +572,17 @@ void NinjaCBinaryTargetWriter::WriteLinkerStuff(
       target_, tool_, tool_->outputs(), &output_files);
 
   out_ << "build";
-  WriteOutputs(output_files);
 
-  out_ << ": " << rule_prefix_ << tool_->name();
+  if (target_->rsp_types().empty()) {
+    WriteOutputs(output_files);
+    out_ << ": " << rule_prefix_
+         << tool_->name();
+  } else {
+    out_ << " ";
+    WriteOutput(OutputFile(target_->label().name() + ".stamp"));
+    out_ << ": " << rule_prefix_;
+    out_ << GeneralTool::kGeneralToolStamp << " |";
+  }
 
   ClassifiedDeps classified_deps = GetClassifiedDeps();
 
@@ -673,7 +681,9 @@ void NinjaCBinaryTargetWriter::WriteLinkerStuff(
 
   // Append implicit dependencies collected above.
   if (!implicit_deps.empty()) {
-    out_ << " |";
+    if (target_->rsp_types().empty()) {
+        out_ << " |";
+    }
     path_output_.WriteFiles(out_, implicit_deps);
   }
 
diff --git a/src/gn/ninja_target_writer.cc b/src/gn/ninja_target_writer.cc
--- a/src/gn/ninja_target_writer.cc
+++ b/src/gn/ninja_target_writer.cc
@@ -18,6 +18,7 @@
 #include "gn/ninja_action_target_writer.h"
 #include "gn/ninja_binary_target_writer.h"
 #include "gn/ninja_bundle_data_target_writer.h"
+#include "gn/ninja_c_binary_target_writer.h"
 #include "gn/ninja_copy_target_writer.h"
 #include "gn/ninja_create_bundle_target_writer.h"
 #include "gn/ninja_generated_file_target_writer.h"
diff --git a/gn/src/gn/rsp_target_writer.cc b/src/gn/rsp_target_writer.cc
new file mode 100644
--- /dev/null
+++ b/src/gn/rsp_target_writer.cc
@@ -0,0 +1,255 @@
+/****************************************************************************
+**
+** Copyright (C) 2021 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the QtWebEngine module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "gn/rsp_target_writer.h"
+#include "base/logging.h"
+#include "base/strings/string_util.h"
+#include "gn/config_values_extractors.h"
+#include "gn/deps_iterator.h"
+#include "gn/ninja_c_binary_target_writer.h"
+#include "gn/ninja_target_command_util.h"
+#include "gn/output_file.h"
+#include "gn/resolved_target_data.h"
+#include "gn/settings.h"
+#include "gn/target.h"
+
+RspTargetWriter::RspTargetWriter(const NinjaCBinaryTargetWriter* writer,
+                                 const Target* target,
+                                 Type type,
+                                 std::ostream& out)
+    : type_(type), target_(target), nwriter_(writer), out_(out) {}
+RspTargetWriter::~RspTargetWriter() {}
+
+// Based on similar function in qt_creator_writer.cc
+static void CollectDeps(std::set<const Target*>& deps, const Target* target) {
+  for (const auto& dep : target->GetDeps(Target::DEPS_ALL)) {
+    const Target* dep_target = dep.ptr;
+    if (deps.count(dep_target))
+      continue;
+    deps.insert(dep_target);
+    CollectDeps(deps, dep_target);
+  }
+}
+
+const ResolvedTargetData& RspTargetWriter::resolved() const {
+  if (!resolved_) {
+    resolved_ = std::make_unique<ResolvedTargetData>();
+  }
+  return *resolved_;
+}
+
+void RspTargetWriter::Run() {
+  CHECK(target_->output_type() == Target::SHARED_LIBRARY ||
+        target_->output_type() == Target::STATIC_LIBRARY)
+      << "RspTargetWriter only supports libraries";
+
+  std::vector<SourceFile> other_files;
+  std::vector<OutputFile> tool_outputs;
+  NinjaBinaryTargetWriter::ClassifiedDeps cdeps = nwriter_->GetClassifiedDeps();
+
+  std::set<const Target*> deps;
+  deps.insert(target_);
+  CollectDeps(deps, target_);
+  const Settings* settings = target_->settings();
+  const CTool* tool =
+      target_->toolchain()->GetToolForTargetFinalOutput(target_)->AsC();
+
+  std::string prefix(
+      settings->build_settings()->build_dir().SourceWithNoTrailingSlash());
+  prefix.append("/");
+#if defined(OS_WIN)
+  prefix.erase(prefix.begin());
+#endif
+  switch (type_) {
+    case NONE:
+      return;
+    case DEFINES: {
+      for (const auto& target : deps) {
+        for (ConfigValuesIterator it(target); !it.done(); it.Next()) {
+          for (std::string define : it.cur().defines()) {
+            out_ << define << " ";
+          }
+        }
+      }
+      out_.flush();
+    } break;
+    case OBJECTS: {
+      PathOutput path_output(settings->build_settings()->build_dir(),
+                             settings->build_settings()->root_path_utf8(),
+                             ESCAPE_NONE);
+      std::vector<SourceFile> object_files;
+      object_files.reserve(target_->sources().size());
+
+      for (const auto& source : target_->sources()) {
+        const char* tool_type = nullptr;
+        if (!target_->GetOutputFilesForSource(source, &tool_type,
+                                              &tool_outputs)) {
+          if (source.GetType() == SourceFile::SOURCE_DEF)
+            other_files.push_back(source);
+          continue;  // No output for this source.
+        }
+        object_files.push_back(
+            tool_outputs[0].AsSourceFile(settings->build_settings()));
+      }
+      if (target_->config_values().has_precompiled_headers()) {
+        const CTool* tool_cxx =
+            target_->toolchain()->GetTool(CTool::kCToolCxx)->AsC();
+        if (tool_cxx && tool_cxx->precompiled_header_type() == CTool::PCH_MSVC) {
+          GetPCHOutputFiles(target_, CTool::kCToolCxx, &tool_outputs);
+          if (!tool_outputs.empty())
+            object_files.push_back(
+                tool_outputs[0].AsSourceFile(settings->build_settings()));
+        }
+      }
+      for (const auto& file : object_files) {
+        out_ << "\"" << prefix;
+        path_output.WriteFile(out_, file);
+        out_ << "\"\n";
+      }
+      for (const auto& file : cdeps.extra_object_files) {
+        out_ << "\"" << prefix;
+        path_output.WriteFile(out_, file);
+        out_ << "\"\n";
+      }
+      out_.flush();
+    } break;
+    case LFLAGS: {
+      EscapeOptions opts;
+      opts.mode = ESCAPE_COMMAND;
+      // First the ldflags from the target and its config.
+      RecursiveTargetConfigStringsToStream(kRecursiveWriterKeepDuplicates,
+                                           target_, &ConfigValues::ldflags,
+                                           opts, out_);
+      out_.flush();
+    } break;
+    case LDIR: {
+      // library dirs
+      const auto& all_lib_dirs = resolved().GetLinkedLibraryDirs(target_);
+      if (!all_lib_dirs.empty()) {
+        PathOutput lib_path_output(settings->build_settings()->build_dir(),
+                                   settings->build_settings()->root_path_utf8(),
+                                   ESCAPE_COMMAND);
+        for (size_t i = 0; i < all_lib_dirs.size(); i++) {
+          out_ << " -L\"";
+          lib_path_output.WriteDir(out_, all_lib_dirs[i],
+                                   PathOutput::DIR_NO_LAST_SLASH);
+          out_ << "\"";
+        }
+        out_.flush();
+      }
+    } break;
+    case ARCHIVES: {
+      PathOutput path_output(settings->build_settings()->build_dir(),
+                             settings->build_settings()->root_path_utf8(),
+                             ESCAPE_NONE);
+      std::vector<OutputFile> solibs;
+      for (const Target* cur : cdeps.linkable_deps) {
+        if (cur->dependency_output_file().value() !=
+            cur->link_output_file().value()) {
+          LOG(ERROR) << "Dependency output file name does not match "
+                        "link output file name:\n" <<
+                        cur->dependency_output_file().value() <<
+                        " vs " <<
+                        cur->link_output_file().value();
+          solibs.push_back(cur->link_output_file());
+        } else {
+          out_ << "\"" << prefix;
+          path_output.WriteFile(out_, cur->link_output_file());
+          out_ << "\"\n";
+        }
+      }
+      out_.flush();
+
+      CHECK(solibs.empty()) << "Unhandled solibs";
+    } break;
+    case LIBS: {
+      EscapeOptions lib_escape_opts;
+      lib_escape_opts.mode = ESCAPE_COMMAND;
+
+      const auto& all_libs = resolved().GetLinkedLibraries(target_);
+      const std::string framework_ending(".framework");
+      for (size_t i = 0; i < all_libs.size(); i++) {
+        const LibFile& lib_file = all_libs[i];
+        const std::string& lib_value = lib_file.value();
+        if (lib_file.is_source_file()) {
+          PathOutput lib_path_output(
+              settings->build_settings()->build_dir(),
+              settings->build_settings()->root_path_utf8(), ESCAPE_COMMAND);
+          out_ << "\"";
+          lib_path_output.WriteFile(out_, lib_file.source_file());
+          out_ << "\"";
+        } else {
+          out_ << " " << tool->lib_switch();
+          EscapeStringToStream(out_, lib_value, lib_escape_opts);
+        }
+      }
+      FrameworksWriter writer(tool->framework_switch());
+      const auto& all_frameworks = resolved().GetLinkedFrameworks(target_);
+      for (size_t i = 0; i < all_frameworks.size(); i++) {
+        writer(all_frameworks[i], out_);
+      }
+      FrameworksWriter weak_writer(tool->weak_framework_switch());
+      const auto& all_weak_frameworks =
+          resolved().GetLinkedWeakFrameworks(target_);
+      for (size_t i = 0; i < all_weak_frameworks.size(); i++) {
+        weak_writer(all_weak_frameworks[i], out_);
+      }
+      out_.flush();
+    }
+  }
+}
+
+RspTargetWriter::Type RspTargetWriter::strToType(const std::string& str) {
+  static std::unordered_map<std::string, RspTargetWriter::Type> const types = {
+      {"objects", RspTargetWriter::OBJECTS},
+      {"archives", RspTargetWriter::ARCHIVES},
+      {"defines", RspTargetWriter::DEFINES},
+      {"lflags", RspTargetWriter::LFLAGS},
+      {"libs", RspTargetWriter::LIBS},
+      {"ldir", RspTargetWriter::LDIR}};
+  auto it = types.find(str);
+  if (it != types.end()) {
+    return it->second;
+  }
+  return RspTargetWriter::NONE;
+}
diff --git a/gn/src/gn/rsp_target_writer.h b/src/gn/rsp_target_writer.h
new file mode 100644
--- /dev/null
+++ b/src/gn/rsp_target_writer.h
@@ -0,0 +1,71 @@
+/****************************************************************************
+**
+** Copyright (C) 2021 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the QtWebEngine module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef TOOLS_GN_RSP_TARGET_WRITER_H_
+#define TOOLS_GN_RSP_TARGET_WRITER_H_
+
+#include <iosfwd>
+#include <memory>
+#include "gn/path_output.h"
+
+class Target;
+class NinjaCBinaryTargetWriter;
+class ResolvedTargetData;
+
+class RspTargetWriter {
+ public:
+  enum Type { NONE, OBJECTS, ARCHIVES, DEFINES, LFLAGS, LIBS, LDIR};
+  RspTargetWriter(const NinjaCBinaryTargetWriter* writer,
+                  const Target* target,
+                  Type type,
+                  std::ostream& out);
+  ~RspTargetWriter();
+  void Run();
+  static Type strToType(const std::string& str);
+  const ResolvedTargetData& resolved() const;
+
+ private:
+  Type type_;
+  const Target* target_;
+  const NinjaCBinaryTargetWriter* nwriter_;
+  std::ostream& out_;
+  mutable std::unique_ptr<ResolvedTargetData> resolved_;
+};
+
+#endif  // TOOLS_GN_RSP_TARGET_WRITER_H_
diff --git a/src/gn/scope_per_file_provider.cc b/src/gn/scope_per_file_provider.cc
--- a/src/gn/scope_per_file_provider.cc
+++ b/src/gn/scope_per_file_provider.cc
@@ -12,7 +12,11 @@
 #include "gn/value.h"
 #include "gn/variables.h"
 
+#ifndef NO_LAST_COMMIT_POSITION
 #include "last_commit_position.h"
+#else
+#define LAST_COMMIT_POSITION_NUM 0
+#endif
 
 ScopePerFileProvider::ScopePerFileProvider(Scope* scope, bool allow_target_vars)
     : ProgrammaticProvider(scope), allow_target_vars_(allow_target_vars) {}
@@ -66,10 +70,10 @@ const Value* ScopePerFileProvider::GetDefaultToolchain() {
 }
 
 const Value* ScopePerFileProvider::GetGnVersion() {
-  if (!gn_version_) {
-    gn_version_ = std::make_unique<Value>(
-        nullptr, static_cast<int64_t>(LAST_COMMIT_POSITION_NUM));
-  }
+   if (!gn_version_) {
+     gn_version_ = std::make_unique<Value>(
+         nullptr, static_cast<int64_t>(LAST_COMMIT_POSITION_NUM));
+   }
   return gn_version_.get();
 }
 
diff --git a/src/gn/target.cc b/src/gn/target.cc
--- a/src/gn/target.cc
+++ b/src/gn/target.cc
@@ -882,6 +882,9 @@ bool Target::FillOutputFiles(Err* err) {
       link_output_file_ = dependency_output_file_ =
           SubstitutionWriter::ApplyPatternToLinkerAsOutputFile(
               this, tool, tool->outputs().list()[0]);
+      if (!rsp_types().empty()) {
+          dependency_output_file_ = OutputFile(label().name() + ".stamp");
+      }
       break;
     case RUST_PROC_MACRO:
     case SHARED_LIBRARY: {
@@ -932,6 +935,9 @@ bool Target::FillOutputFiles(Err* err) {
         SubstitutionWriter::ApplyListToLinkerAsOutputFile(
             this, tool, *runtime_outputs_ptr, &runtime_outputs_);
       }
+      if (!rsp_types().empty()) {
+          dependency_output_file_ = OutputFile(label().name() + ".stamp");
+      }
       break;
     }
     case UNKNOWN:
diff --git a/src/gn/target.h b/src/gn/target.h
--- a/src/gn/target.h
+++ b/src/gn/target.h
@@ -190,6 +190,7 @@ class Target : public Item {
     SourceDir rebase_;
     std::vector<std::string> data_keys_;
     std::vector<std::string> walk_keys_;
+    std::vector<std::string> rsp_types_;
   };
   const GeneratedFile& generated_file() const;
   GeneratedFile& generated_file();
@@ -215,6 +216,9 @@ class Target : public Item {
   }
   std::vector<std::string>& walk_keys() { return generated_file().walk_keys_; }
 
+  std::vector<std::string>& rsp_types() { return generated_file().rsp_types_; }
+  const std::vector<std::string>& rsp_types() const { return generated_file().rsp_types_; }
+
   OutputFile write_runtime_deps_output() const {
     return write_runtime_deps_output_;
   }
diff --git a/src/gn/target_generator.cc b/src/gn/target_generator.cc
--- a/src/gn/target_generator.cc
+++ b/src/gn/target_generator.cc
@@ -58,6 +58,9 @@ void TargetGenerator::Run() {
   if (!FillTestonly())
     return;
 
+  if (!FillRspTypes())
+    return;
+
   if (!FillAssertNoDeps())
     return;
 
@@ -313,6 +316,27 @@ bool TargetGenerator::FillTestonly() {
   return true;
 }
 
+bool TargetGenerator::FillRspTypes() {
+  const Value* value = scope_->GetValue(variables::kRspTypes, true);
+  if (!value)
+    return true;
+  if (!value->VerifyTypeIs(Value::LIST, err_))
+    return false;
+
+  const std::vector<Value>& value_list = value->list_value();
+  std::vector<std::string>& rsp_types = target_->rsp_types();
+  rsp_types.reserve(value_list.size());
+
+  for (size_t i = 0; i < value_list.size(); i++) {
+    const Value& v = value_list[i];
+    if (!v.VerifyTypeIs(Value::STRING, err_))
+      return false;
+    const std::string str = v.string_value();
+    rsp_types.push_back(str);
+  }
+  return true;
+}
+
 bool TargetGenerator::FillAssertNoDeps() {
   const Value* value = scope_->GetValue(variables::kAssertNoDeps, true);
   if (value) {
diff --git a/src/gn/target_generator.h b/src/gn/target_generator.h
--- a/src/gn/target_generator.h
+++ b/src/gn/target_generator.h
@@ -70,6 +70,7 @@ class TargetGenerator {
   bool FillDependencies();  // Includes data dependencies.
   bool FillMetadata();
   bool FillTestonly();
+  bool FillRspTypes();
   bool FillAssertNoDeps();
   bool FillWriteRuntimeDeps();
 
diff --git a/src/gn/variables.cc b/src/gn/variables.cc
--- a/src/gn/variables.cc
+++ b/src/gn/variables.cc
@@ -2229,6 +2229,30 @@ Example
   }
 )";
 
+const char kRspTypes[] = "rsp_types";
+const char kRspTypes_HelpShort[] =
+    "rsp_types: [string list] A list of rsp files to create wih linker "
+    "information for given target.";
+const char kRspTypes_Help[] =
+    "rsp_types: Declares a target that instead of liking dumps the information "
+    "to set of rsp files.\n"
+    "\n"
+    "  Defaults to ["
+    "].\n"
+    "\n"
+    "  When a target is marked \"rsp_types = [ \"objects\" , \"archives\" ... "
+    "]\" and is linkable,"
+    "  the linking step  is skipped. Instead linking infomation is dumped as a "
+    "set of responses file containing"
+    "  selected types of information\n"
+    "\n"
+    "Example\n"
+    "\n"
+    "  static_library(\"test_support\") {\n"
+    "    rsp_types = \"libs\"\n"
+    "    ...\n"
+    "  }\n";
+
 const char kVisibility[] = "visibility";
 const char kVisibility_HelpShort[] =
     "visibility: [label list] A list of labels that can depend on a target.";
diff --git a/src/gn/variables.h b/src/gn/variables.h
--- a/src/gn/variables.h
+++ b/src/gn/variables.h
@@ -346,6 +346,10 @@ extern const char kTestonly[];
 extern const char kTestonly_HelpShort[];
 extern const char kTestonly_Help[];
 
+extern const char kRspTypes[];
+extern const char kRspTypes_HelpShort[];
+extern const char kRspTypes_Help[];
+
 extern const char kVisibility[];
 extern const char kVisibility_HelpShort[];
 extern const char kVisibility_Help[];
diff --git a/src/util/build_config.h b/src/util/build_config.h
--- a/src/util/build_config.h
+++ b/src/util/build_config.h
@@ -135,7 +135,7 @@
 #define ARCH_CPU_ARMEL 1
 #define ARCH_CPU_32_BITS 1
 #define ARCH_CPU_LITTLE_ENDIAN 1
-#elif defined(__aarch64__)
+#elif defined(__aarch64__) || defined(_M_ARM64)
 #define ARCH_CPU_ARM_FAMILY 1
 #define ARCH_CPU_ARM64 1
 #define ARCH_CPU_64_BITS 1
diff --git a/src/util/sys_info.cc b/src/util/sys_info.cc
--- a/src/util/sys_info.cc
+++ b/src/util/sys_info.cc
@@ -87,6 +87,8 @@ std::string OperatingSystemArchitecture() {
       return "x86";
     case PROCESSOR_ARCHITECTURE_AMD64:
       return "x86_64";
+    case PROCESSOR_ARCHITECTURE_ARM64:
+      return "arm64";
     case PROCESSOR_ARCHITECTURE_IA64:
       return "ia64";
   }
